<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/monokai.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1>Streams</h1>
        <h2>Your New Favorite Primitive</h2>
        <h3>- Ryan Peters</h3>
      </section>
      <section>
        <section>
          <h2>Subject of this talk:</h2>
          <p>The year is 2020.</p>
          <p class="fragment">A new form of "streams" are becoming a general-purpose programming primitive.</p>
          <p class="fragment">Not all languages and libraries approach them equally.</p>
          <p class="fragment">That said...</p>
          <p class="fragment">Once you know one, to an extent, you know them all.</p>
        </section>
        <section>
          <h2>Streaming with FS2</h2>
          <p>My streaming library of choice in Scala is FS2.</p>
          <p class="fragment">FS2 is inspired by - and also inspires - other libraries from other ecosystems.</p>
          <p class="fragment">Most things here are applicable in almost any other language or streaming library.</p>
        </section>
      </section>
      <section>
        <section>
          <h2>My History With Streams</h2>
        </section>
        <section data-background="img/Rx_Logo-512-512.png" data-background-size="50%" data-background-opacity="0.66">
          <h2>Back in 2016...</h2>
          <ul style="list-style:none">
            <li>I got in to Angular in JavaScript...</li>
            <li>Which got me into RxJS</li>
          </ul>
        </section>
        <section>
          <h2>RxJS "Observables"</h2>
          <table>
            <tr>
              <th></th>
              <th>Single</th>
              <th>Multiple</th>
            </tr>
            <tr>
              <td style="font-weight:bold">Pull</td>
              <td>Function</td>
              <td>Iterator</td>
            </tr>
            <tr>
              <td style="font-weight:bold">Push</td>
              <td>Promise</td>
              <td>Observable</td>
            </tr>
          </table>
        </section>
        <section data-background-iframe="https://reactivex.io/" data-background-interactive>

        </section>
        <section>
          <h2>Takeaways:</h2>
          <ul>
            <li>Streaming "can be" async - but doesn't have to be</li>
            <li>Useful as a general-purpose primitive</li>
            <li>"Observables" == "Streams" in other libs</li>
            <p>(PS: Monix is like ReactiveX in Scala)</p>
          </ul>
        </section>
      </section>
      <section>
        <section>
          <h2>A Streaming Vocabulary</h2>
          <p>A stream:</p>
          <ul>
            <li>Is an "iterable-like" interface for processing ordered elements</li>
            <li>Has "operators" that append new steps in the "pipeline"</li>
            <li>Can be composed together to produce entire program flows</li>
          </ul>
        </section>
        <section>
          <h3>Other common concepts:</h3>
          <ul>
            <li>
              A "Single" stream - always has 1 element
              <p style="font-size: 66%">(In Scala this is just <span class="mono">IO / Future</span> thanks to
                map/flatmap)</p>
            </li>
            <li>Subjects/Topics/Queues - Stream-enabled concurrency primitives</li>
            <li>A way to define custom operators (GraphStage, Pull, etc.)</li>
          </ul>
        </section>
        <section>
          <h3>FS2 Stream</h3>
          <p>Looks like: <p><span class="mono-pad">Stream[F[_], A]</span></p>
          </p>
          <ul>
            <li>
              <span class="mono">F[_]</span> is the effect type
            </li>
            <li><span class="mono">A</span> is the element type</li>
          </ul>
        </section>
        <section>
          <h3>Pure Streams</h3>
          <pre><code class="hljs scala" data-trim>
import fs2.{Pure, Stream}

val pureStream: Stream[Pure, Int] = Stream(1, 2, 3)
pureStream.map(_ - 1).compile.toList // List(0, 1, 2)
          </code></pre>
        </section>
        <section>
          <h3>Streaming side-effects</h3>
          <pre><code class="hljs scala" data-trim data-line-numbers="|1-3|1-5|3,6-10|6-13|">
import cats.effect.IO

def putstrln(s: String): IO[Unit] = IO(println(s))

val pureStream = Stream(1, 2, 3)
val printEverything: IO[Unit] =
  pureStream
    .evalMap(putstrln) //Now we have a Stream[IO, Int]
    .compile
    .drain //Discards all results, since "Unit" is useless

//Prints 1, 2, 3 on separate lines
printeverything.unsafeRunSync()
          </code></pre>
        </section>
        <section>
          <h3>Compiling Streams</h3>
          <p>Streams in FS2 must be "compiled" to a value</p>
          <p>"Pure" streams are executed immediately</p>
          <p>Effectful streams must compile to an <span class="mono">F[_]</span> value</p>
        </section>
        <section>
          <h3>Other Useful Compile Operators</h3>
          <ul>
            <li>fold - Just like foldLeft on <span class="mono">List</span></li>
            <li>last - Gives <span class="mono">F[Option[A]]</span></li>
            <li>string - Efficiently concatenates a stream of Strings w/ StringBuilder</li>
            <li>to(Col) - Collect results to a collection (great for tests)</li>
          </ul>
        </section>
      </section>
      <section>
        <section>
          <h2>Streams are... Complicated?</h2>
        </section>
        <section>
          <ul>
            <li>Joined Rewards Network in 2018</li>
            <li>Started out w/ Akka & Akka Streams</li>
            <li>Not everyone was super FP-familiar</li>
          </ul>
        </section>
        <section>
          <ul>
            <li>We had an event-driven application</li>
            <li class="fragment">...Implemented with loops and mutability</li>
            <li class="fragment">"A natural streaming use-case!" -me</li>
            <li class="fragment">Redid some code w/ Akka Streams</li>
            <li class="fragment">It did not go over well w/ the maintainer</li>
          </ul>
        </section>
        <section>
          <h3>Diagnosing the issues</h3>
          <ol>
            <li>Akka Streams is conceptually large</li>
            <li>Cost/Benefit of bringing in a library "just" to solve a simple, one-off problem</li>
            <li>Misconceptions as to when streams are "necessary"</li>
          </ol>
        </section>
        <section>
          <h3>RE: Akka Streams</h3>
          <ul>
            <li>Akka Streams is conceptually large</li>
            <li>"Streams" are actually Sources/Sinks/Flows</li>
            <li>...And those all have "shapes"</li>
            <li>...And you compose them with a custom "graph DSL"</li>
            <li>CAN be done functionally, but it's not actively encouraged</li>
            <li>Engineered to mesh well with Actor-based programming, which is complex</li>
          </ul>
        </section>
        <section>
          <h3>Streaming "Cost/Benefits"</h3>
          <ul>
            <li>Streams are an general abstraction</li>
            <li>Once you know a concept - you can apply it anywhere</li>
            <li>Everybody benefits from knowing functional streaming</li>
            <li>You already know it</li>
          </ul>
        </section>
        <section>
          <h3>When are streams "necessary?"</h3>
          <p class="fragment">The answer...</p>
          <p class="fragment">...Is a lot more often than you'd think!</p>
        </section>
        <!-- <section>
          <h2>A Bit About Actors</h2>
          <p>Akka Streams is an actor-based streaming solution</p>
          <p>Actors are "push-based" and queue up - takes a lot of boilerplate to make streaming work</p>
          <p>This is because actors do not handle "backpressure"</p>
        </section> -->
      </section>
      <section>
        <section>
          <h2>A "YAGNI" Fallacy</h2>
          <p>Sometimes the best thing to do...</p>
          <p class="fragment">...Is the simplest thing to do...</p>
          <p class="fragment">...But what is the simplest thing to do?</p>
        </section>
        <section>
          <h3>Which is "simpler?"</h3>
          <pre><code class="hljs scala" data-trim>
/** Returns `null` if no string exists */
def getStringOne: String

/** Returns `None` if no string exists */
def getStringTwo: Option[String]
          </code></pre>
        </section>
        <section>
          <p>Abstractions can be premature,</p>
          <p class="fragment">or exactly what we want.</p>
          <p class="fragment">Bad abstractions have limited applicability.</p>
          <p class="fragment">Good abstractions show their usefulness everywhere.</p>
          <p class="fragment">All abstractions - good and bad - require learning first.</p>
        </section>
      </section>
      <section>
        <section>
          <h2>A Stream of Inspiration</h2>
        </section>
        <section>
          <h3>FS2-IO Module</h3>
          <ul>
            <li>File reading/writing</li>
            <li>TCP/UDP sockets</li>
            <li>StdIn/StdOut streaming</li>
            <li>New (v2.2): TLS support</li>
            <li>All have raw byte support, converting formats</li>
          </ul>
        </section>
        <section>
          <p>Find all file lines w/ "password"</p>
          <pre><code class="hljs scala" data-trim data-line-numbers="|1|2-4|6,7|8,9|8-12|8-13|">
val blocker: Blocker = ??? //A blocking ExecutionContext
val docPath =
  java.nio.file.Paths.get("/home/rpeters/Documents")
val outFile = docPath.resolveSibling("out.txt")

//Start w/ a stream of all files in my home directory
fs2.io.file.walk(blocker, homePath).flatMap { path =>
  //Read the file in, 512 bytes at a time
  fs2.io.file.readAll(path, blocker, 512)
    .through(fs2.text.decodeUtf8) //Decode to String
    .through(fs2.text.lines) //Extract lines
    .filter(_.toLowerCase.contains("password"))
    .through(fs2.io.writeAll[IO](outFile, blocker))
}.compile.drain.unsafeRunSync()
          </code></pre>
        </section>
        <section>
          <h3>Database Streaming w/ Doobie</h3>
          <p>Doobie is a pure JDBC wrapper built on Cats Effect</p>
          <pre><code class="hljs scala" data-trim data-line-numbers="|1,2|4-8|10,11|13|">
//Runs DB transactions as your F[_] of choice
val xa: Transactor[IO] = ???

//Represents a step in a DB connection
val userQuery: ConnectionIO[List[(String, Int)]] =
  sql"SELECT username, age FROM users"
    .query[(String, Int)]
    .toList

val runQuery: IO[List[(String, Int)]] =
  userQuery.transact(xa)

runQuery.flatMap(user => IO(println(user)))
          </code></pre>
        </section>
        <section>
          <p>Queries can also be streamed</p>
          <pre><code class="hljs scala" data-trim data-line-numbers="|1|5|7|8|">
def sendBetaInvite(u: UserAccount): IO[Unit]

sql"SELECT username, email FROM users WHERE banned = false"
  .query[(String, String)]
  .stream //Stream[ConnectionIO, (String, String)]
  .map(UserAccount(_, _, banned = false))
  .transact(xa) //Stream[IO, UserAccount]
  .parEvalMap(32)(user => sendBetaInvite(user))
  .compile
  .drain
          </code></pre>
          <p class="fragment"><span class="mono">parEvalMap</span> runs N evaluations in parallel</p>
        </section>
        <section>
          <h3>http4s - Streaming Requests</h3>
          <p>http4s is a pure HTTP server and client library</p>
          <pre><code class="hljs scala" data-trim data-line-numbers="|1,2|4|4-14|">
def sendWorkRequest(work: UnitOfWork): IO[Unit] = ???
def parseUnitOfwork(s: String): Option[UnitOfWork] = ???

val routes = HttpRoutes.of[IO] {
  case req @ POST -> Root / "work" / "submit" =>
    req.through(fs2.text.utf8decode)
      .through(fs2.text.lines)
      .map(parseUnitOfWork)
      .unNone //Filters out "None" from the stream
      .parEvalMap(32)(sendWorkRequest)
      .compile
      .drain
      .flatMap(_ => Ok("Work requests sent!"))
}
          </code></pre>
          <p class="fragment">In http4s, every request/response is a stream</p>
        </section>
        <section>
          <h3>FS2-SSH - Streaming SSH In Scala</h3>
          <pre><code class="hljs scala" data-trim>
def runScript(blocker: Blocker, client: Client[F], cc: ConnectionConfig)(implicit F: FunctorRaise[F, Client.Error]) {
  client.exec(connectionConfig, "/path/to/script.sh", blocker) { process =>
    process.stdout //A stream of raw byte output
      .through(fs2.text.decodeUtf8)
      .through(fs2.text.lines)
      .filterNot(_.contains("log"))
      .showLinesStdout
      .compile
      .drain
  }
}
          </code></pre>
          <p class="fragment">Also supports stderr, stdin, joining</p>
        </section>
      </section>
      <section>
        <section>
          <h2>Streaming Patterns</h2>
        </section>
        <section>
          <p>Run your whole program as concurrent streams</p>
          <pre><code class="hljs scala" data-trim>
val httpServer: Stream[IO, Unit] = ???
val handleMessagesFromKafka: Stream[IO, Unit] = ???
val processAsyncRequests: Stream[IO, Unit] = ???

//A stream of streams - super streamy! :)
Stream(
  httpServer,
  handleMessagesFromKafka,
  processAsyncRequests
).parJoinUnbounded //Run all streams concurrently
  .compile
  .drain
  .as(ExitCode.Success)
          </code></pre>
        </section>
        <section>
          <h3>Event-driven State</h3>
          <p>Front-end and back-end apps can benefit from having state be event-driven</p>
          <p>Sometimes called "Event Sourcing"</p>
          <p>Also used in Flux/Redux in JavaScript</p>
          <pre><code class="hljs scala" data-trim>
val accumulateState: Pipe[Pure, Int, Int] = { stream =>
  stream.scan(0)(_ + _)
}

val eventStream = Stream(1, 2, 3)

val finalState = eventStream
  .through(accumulateState)
  .compile
  .lastOrError //Final state is 6
          </code></pre>
        </section>
        <section>
          <p>For some extra event-sourcing utils, try FS2-ES*</p>
          <pre><code class="hljs scala" data-trim>
import dev.rpeters.fs2.es._

val stateProgram: IO[(List[Int], Int)] = for {
  eventState <- EventState[IO].initial[Int, Int](0)(_ + _)
  states <- Stream(1, 2, 3)
    .through(eventState.hookup) //Stream of resulting states
    .compile
    .toList
  currentState <- eventState.get //Gets the current state
} yield allStates -> currentState
          </code></pre>
          <p class="fragment">*Shill Alert: I wrote this one!</p>
          <p class="fragment">Also includes a state cache & other helpful utils</p>
        </section>
      </section>
      <!-- <section> -->
      <!-- <section>
          <h2>A Path to FS2 Streaming</h2>
        </section>
        <section>
          <h2>Loops (Yay...)</h2>
          <pre><code class="hljs scala" data-line-numbers="|1|3-7|9-13" data-trim>
val list = List(1, 2, 3)

//Using a classic "for-loop"
for { i <- (0 to (list.length - 1)) } yield {
  val next = list(i)
  println(next)
}

//Using an Iterator
val it = list.iterator
while (it.hasNext) {
  println(it.next)
}
          </code></pre>
        </section>
        <section>
          <h2>Lets Get Functional!</h2>
          <pre><code class="hljs scala" data-line-numbers="|1|3,4|6-8|10,11" data-trim>
val list = List(1, 2, 3)

//The magic of "forEach" :O
list.forEach(println)

//Infinite collections with Stream/LazyList
val lazyList = LazyList.iterate(0)(_ + 1)
lazyList.forEach(println) //Will run forever

//Infinite collections until an arbitrary point
lazyList.take(256).forEach(println) //Will print 256 times
          </code></pre>
        </section>
      </section>
      <section>
        <h2>Lets Go Further</h2>
        <ol>
          <li class="fragment">Asynchronicity</li>
          <li class="fragment">Represent a long-running program</li>
          <li class="fragment">Handle side-effects (eventually)</li>
        </ol>
      </section> -->
    </div>
  </div>

  <script src="js/reveal.min.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      hash: true,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/highlight/highlight.js' },
        { src: 'plugin/notes/notes.js', async: true }
      ]
    });
  </script>
</body>

</html>
